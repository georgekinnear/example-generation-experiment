---
title: "Study 1 analysis"
author: "George Kinnear"
date: "18/05/2021"
output: 
  html_document:
    code_folding: hide
    df_print: paged
---

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)

#Plots
library(ggplot2)
library(patchwork) # for combining plots
library(ggtext) # for markdown in plots

# For Bayesian stats:
library(bayestestR)
#library(insight)
#library(see)
library(rstanarm)
library(tidybayes)
#library(BayesFactor)
ci_width = 0.95  # Use 95% HDIs
set.seed(20210518)

# Tables
library(knitr)
library(kableExtra)
basic_kable = function(df, ...) {
  df %>% 
    kable(...) %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
}

# Plot styling
heathers = c("#00b3c3","#e51c24","#016637","#fcb123")
heathers = c("#87005a", "#c66005","#016637","#fcb123")
groupcolours = c("C-CG" = heathers[1],
                 "C-GC" = "#6f004a", # darker heathers1
                 "G-CG" = heathers[2],
                 "G-GC" = "#a34e03" # darker heathers2
                 )
four_groups = c("CCG", "CGC", "GCG", "GGC")
theme_set(theme_minimal())
```

For this analysis we use "intention to treat", i.e. we include all students who consented to participate, without regard for whether (or the extent to which) they engaged with the experimental tasks.

```{r read-data, message=FALSE, warning=FALSE}
question_marks = read_csv("data-clean/study1/FAC_LGE-tasks.csv") %>%
  select(question_name, marks_available)

attempt_data_all = read_rds("data-clean/FAC_LGE-attempt_data.rds") %>% 
  # tidy up group names
  mutate(
    group = str_replace(group, "LGE Group ", ""),
    group = str_glue("{str_sub(group, 1, 1)}-{str_sub(group, 2, 3)}"),
    overall_group = str_sub(group, 1, 1)
  ) %>% 
  mutate(
    quiz = case_when(
      question_name %in% c("FarC1", "FarC2") ~ "FT",
      str_detect(question_name, "Mid") ~ "S2",
      TRUE ~ "S1"
    )
  ) %>% 
  left_join(question_marks, by = "question_name") %>% 
  mutate(
    # default to 1 mark per question if not specified
    marks_available = replace_na(marks_available, 1),
    marks_attained = fraction * marks_available
  )
```

# Data summary

```{r}
first_attempts_summary = attempt_data_all %>% 
  filter(attempt_number == 1) %>% 
  group_by(overall_group, group, username, quiz) %>% 
  summarise(
    marks_prop = sum(marks_attained, na.rm = TRUE) / sum(marks_available, na.rm = TRUE),
    n = n(),
    num_nas = sum(is.na(fraction)),
    num_qs = n_distinct(question_name),
    .groups = "drop"
  )

first_attempts_summary %>% 
  group_by(quiz) %>% 
  summarise(
    n_students = n(),
    marks_mean = mean(marks_prop),
    marks_sd = sd(marks_prop),
    .groups = "drop"
  ) %>% 
  basic_kable()

first_attempts_summary %>% 
  group_by(quiz, overall_group, group) %>% 
  summarise(
    n_students = n(),
    marks_mean = mean(marks_prop),
    marks_sd = sd(marks_prop),
    num_qs_in_quiz = max(num_qs),
    overall_nas = mean(num_nas) / num_qs_in_quiz,
    .groups = "drop"
  ) %>% 
  basic_kable()
```

# Item performance

TODO - bring in plots from 3c_check_learning_tasks.R

```{r}
first_attempts = attempt_data_all %>% 
  filter(attempt_number == 1) %>% 
  group_by(quiz, question_name, username) %>% 
  select(quiz, question_name, username, fraction, attempt_number) %>% 
  ungroup()

last_attempts = attempt_data_all %>% 
  group_by(quiz, question_name, username) %>% 
  # select the final attempt
  top_n(n = 1, wt = attempt_number) %>% 
  select(quiz, question_name, username, fraction, attempt_number) %>% 
  ungroup()

best_attempts = attempt_data_all %>% 
  group_by(quiz, question_name, username) %>% 
  # select the best attempt
  top_n(n = 1, wt = fraction) %>% 
  slice(1) %>% 
  select(quiz, question_name, username, fraction, attempt_number) %>% 
  ungroup()

attempts_summary = bind_rows(
  list("first" = first_attempts,
       "last" = last_attempts,
       "best" = best_attempts),
  .id = "attempt_type"
)

attempts_summary_stats = attempts_summary %>% 
  filter(attempt_type != "best") %>% 
  group_by(quiz, question_name, attempt_type) %>% 
  summarise(
    mean_score = mean(fraction, na.rm = TRUE),
    null_response = sum(is.na(fraction)) / n(),
    n = n(),
    .groups = "drop"
  ) %>% 
  ungroup() %>% 
  mutate(
    plot_order = case_when(
      str_detect(question_name, "^C") ~ "1. Learning (C)",
      str_detect(question_name, "^G") ~ "1. Learning (G)",
      str_detect(question_name, "Near") ~ "2. Near",
      str_detect(question_name, "Mid") ~ "3. Mid",
      str_detect(question_name, "Far") ~ "4. Far"
    )
  )
```

This shows the mean score on each of the items:

```{r}
attempts_summary_stats %>% 
  ggplot(aes(x = question_name,
             y = mean_score,
             colour = attempt_type,
             group = attempt_type)) +
  geom_point() +
  geom_line() +
  geom_point(data = attempts_summary_stats,
             mapping = aes(x = question_name,
                 y = null_response),
             shape = 1) +
  facet_wrap(~plot_order, scales = "free_x") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  ylim(c(0,1)) +
  labs(caption = "Hollow points show the proportion of null responses")
```

## Initial learning task: Classification

```{r}
# Separate the raw response data into details of the 10 different sub-parts
# - extract the details of which sub-part is which of the Alcock & Simpson items (item_part)
# - plus the corresponding response (ans_part) and score (score_part) for each sub-part
responses_C1 <- attempt_data_all %>%
  filter(question_name == "C1",
         attempt_number == 1,
         !is.na(marks_attained)) %>%
  select(group, username, questionsummary, responsesummary, marks_attained) %>% 
  # pick out the responses to each part
  # STACK output uses [score] to separate the responses to each part; use NA to discard the final bit that is about the PRTs
  separate(col = responsesummary,
           into = c(paste0("ans_part", c(1:10)), NA),
           sep = "\\[score\\]; ",
           remove = FALSE) %>% 
  mutate(across(contains("ans"), ~ str_remove(., ".*: "))) %>% 
  # pick out the scores for each part (this time discarding the first bit that holds the responses)
  separate(col = responsesummary,
           into = paste0("score_part", c(0:10)),
           sep = "\\| prt") %>% 
  select(-score_part0) %>% 
  mutate(across(contains("score"), ~ str_remove(., ";.*"))) %>% 
  mutate(across(contains("score"), ~ str_remove(., ".*-.*-"))) %>% 
  mutate(questionsummary = str_remove_all(questionsummary, "\\[|\\]")) %>% 
  separate(col = questionsummary,
           into = paste0("item_part", c(1:10)),
           sep = ",")

responses_C2 <- attempt_data_all %>%
  filter(question_name == "C2",
         attempt_number == 1,
         !is.na(marks_attained)) %>%
  select(group, username, questionsummary, responsesummary, marks_attained) %>% 
  # pick out the responses to each part
  separate(col = responsesummary,
           # interleave vectors https://stackoverflow.com/a/50516988
           into = c(as.vector(rbind(paste0("ans_part", c(11:13)),c(NA,NA,NA))), NA),
           sep = "\\[score\\]; ",
           remove = FALSE) %>% 
  mutate(across(contains("ans"), ~ str_remove(., ".*: "))) %>% 
  # pick out the scores for each part (this time discarding the first bit that holds the responses)
  separate(col = responsesummary,
           into = c(NA, as.vector(rbind(paste0("score_part", c(11:13)),c(NA,NA,NA)))),
           sep = "\\| prt") %>% 
  mutate(across(contains("score"), ~ str_remove(., ";.*"))) %>% 
  mutate(across(contains("score"), ~ str_remove(., ".*-.*-"))) %>% 
  mutate(questionsummary = str_remove_all(questionsummary, "\\[|\\]")) %>% 
  separate(col = questionsummary,
           into = paste0("item_part", c(11:13)),
           sep = ",") %>% 
  # make the item numbers 11,12,13 instead of 1,2,3
  rowwise() %>% 
  mutate(across(contains("item_part"), ~ as.character(sum(c(as.numeric(.x), 10)))))

responses_C3 <- attempt_data_all %>%
  filter(question_name == "C3",
         attempt_number == 1,
         !is.na(marks_attained)) %>%
  select(group, username, questionsummary, responsesummary, marks_attained) %>% 
  # pick out the responses to each part
  separate(col = responsesummary,
           into = c(paste0("ans_part", c(14:15)), NA),
           sep = "\\[score\\]; ",
           remove = FALSE) %>% 
  mutate(across(contains("ans"), ~ str_remove(., ".*: "))) %>% 
  # pick out the scores for each part (this time discarding the first bit that holds the responses)
  separate(col = responsesummary,
           into = c(NA,paste0("score_part", c(14:15))),
           sep = "\\| prt") %>% 
  mutate(across(contains("score"), ~ str_remove(., ";.*"))) %>% 
  mutate(across(contains("score"), ~ str_remove(., ".*-.*-"))) %>% 
  mutate(questionsummary = str_remove_all(questionsummary, "\\[|\\]")) %>% 
  separate(col = questionsummary,
           into = paste0("item_part", c(14:15)),
           sep = ",") %>% 
  # make the item numbers 14,15 instead of 1,2
  rowwise() %>% 
  mutate(across(contains("item_part"), ~ as.character(sum(c(as.numeric(.x), 13)))))

responses_C_long = responses_C1 %>% 
  select(-marks_attained) %>% 
  full_join(responses_C2 %>% select(-marks_attained), by = c("group", "username")) %>% 
  full_join(responses_C3 %>% select(-marks_attained), by = c("group", "username")) %>% 
  pivot_longer(
    # take variables of the form STUFF_partN and separate
    # into a column for each kind of STUFF and store the
    # values of N in a column called "part"
    contains("part"),
    names_to = c(".value", "part"),
    names_sep = "_part"
  ) %>% 
  mutate(score = if_else(score == "T", 1, 0)) %>% 
  mutate(score = replace_na(score, 0),
         item = as.integer(item),
         item = as.factor(item),
         ans = str_remove_all(ans, '\\"| '),
         ans = na_if(ans, ""))
```

```{r}
responses_C_summary = responses_C_long %>% 
  # we are only interested in responses from the students completing the question during the learning task,
  # not students from the G- group completing the question later when the materials were made available
  filter(str_detect(group, "C-")) %>% 
  group_by(item, ans) %>% 
  summarise(
    count = n(),
    .groups = "drop"
  ) %>% 
  arrange(item) %>% 
  group_by(item) %>% 
  mutate(
    correct_ans = case_when(
      item %in% c(2,9,11,13,15) & ans == "Increasing" ~ "Correct",
      item %in% c(3,10) & ans == "Decreasing" ~ "Correct",
      item %in% c(1,4,5,6,7,8,12,14) & ans == "Neither" ~ "Correct",
      TRUE ~ "Incorrect"
    ),
    signed_count = if_else(correct_ans == "Correct", count, -count),
    signed_prop = signed_count / sum(count*!is.na(ans))
  ) %>% 
  drop_na()

options(knitr.kable.NA = '')
responses_C_summary %>% 
  pivot_wider(
    id_cols = item,
    names_from = ans,
    values_from = count
  ) %>% 
  basic_kable(
    #format = "latex", booktabs = T
  )

library(latex2exp)
windowsFonts(Times=windowsFont("TT Times New Roman"))
responses_C_summary %>% 
  mutate(item = as.numeric(item)) %>% 
  ggplot(aes(x = item, y = signed_count, fill = ans)) +
  geom_bar(position = "stack", stat = "identity") +
  geom_hline(yintercept = 0) +
  #scale_fill_viridis_d("Answer", end = 0.85, option = "viridis") +
  scale_fill_viridis_d("Answer", option = "plasma", end = 0.8, direction = -1) +
  #scale_fill_grey("Answer", end = 0.8) +
  scale_y_continuous("Number of responses", labels = abs, breaks = seq(-40, 40, 20)) +
  scale_x_reverse(
    position = "top",
    breaks = c(1:15),
    minor_breaks = c(1:15),
    labels = c(
      "1" = parse(text = TeX("1. (0,1,0,1,0,1,0,1,\\ldots)")),
      "2" = parse(text = TeX("2. (1, 4, 9, 16, 25, 36, 49, 64,\\ldots)")),
      "3" = parse(text = TeX("3. (1,\\frac{1}{2},\\frac{1}{3},\\frac{1}{4},\\frac{1}{5},\\frac{1}{6},\\frac{1}{7},\\frac{1}{8},\\ldots)")),
      "4" = parse(text = TeX("4. (1,-1,2,-2,3,-3,4,-4,\\ldots)")),
      "5" = parse(text = TeX("5. (3,3,3,3,3,3,3,3,\\ldots)")),
      "6" = parse(text = TeX("6. (1, 3, 2, 4, 3, 5, 4, 6,\\ldots)")),
      "7" = parse(text = TeX("7. (6, 6, 7, 7, 8, 8, 9, 9,\\ldots)")),
      "8" = parse(text = TeX("8. (0, 1, 0, 2, 0, 3, 0, 4,\\ldots)")),
      "9" = parse(text = TeX("9. (\\frac{1}{2}, \\frac{3}{4}, \\frac{7}{8}, \\frac{15}{16}, \\frac{31}{32}, \\frac{63}{64}, \\frac{127}{128}, \\frac{255}{256},\\ldots)")),
      "10" = parse(text = TeX("10. (-2,-4,-6,-8,-10,-12,-14,-16,\\ldots)")),
      "11" = parse(text = TeX("11. u_n = n^2+1")),
      "12" = parse(text = TeX("12. u_n = 3+(-1)^n")),
      "13" = parse(text = TeX("13. u_n = 5-1/(2^n)")),
      "14" = parse(text = TeX("14. Plot of u_n = 3+(-1)^n")),
      "15" = parse(text = TeX("15. Plot of u_n = 5-3/n"))
    )
  ) +
  labs(x = "") +
  coord_flip() +
  expand_limits(y = c(-40,40)) +
  annotate("text", x = -0.5, y = 5, label = "Correct", fontface = "bold", hjust = "left", vjust = "top") +
  annotate("text", x = -0.5, y = -5, label = "Incorrect", fontface = "bold", hjust = "right", vjust = "top") +
  theme(axis.text.y = element_text(family="Times"),
        panel.grid.minor.x = element_blank(),
        legend.position = "left")

ggsave("figs/FIG_study1_responses_C.pdf", width = 18, height = 12, units = "cm")
```


## Initial learning task: Example generation

```{r}
responses_G <- attempt_data_all %>%
  filter(
    str_detect(question_name, "^G"),
    # focus on students doing this as their initial learning task
    str_detect(group, "G-"),
    attempt_number == 1,
    !is.na(marks_attained)
  ) %>% 
  select(group, username, question_name, questionsummary, responsesummary, marks_attained) %>% 
  # pick out the various answers - str_match_all returns a matrix, which we have to wrangle a bit
  mutate(ans_bits = str_match_all(responsesummary, "(ans[:digit:]): ([^;]*)(?=\\[score\\];)")) %>% 
  mutate(ans_bits = map(ans_bits, ~ tibble(part = .x[,2], response = .x[,3]))) %>% 
  unnest(ans_bits) %>% 
  # this pulls out all the PRT parts, but we don't actually need to - see "fully_correct" below
  #mutate(prt_bits = str_match_all(responsesummary, "(prt[:digit:]): ([^;]*)(?=; |$)")) %>% 
  #mutate(prt_bits = map(prt_bits, ~ tibble(prt = .x[,2], tree = .x[,3]))) %>% 
  #unnest(prt_bits) %>% 
  # construct a simplified name for each question part
  mutate(
    G_part = case_when(
      question_name %in% c("Ga", "Gb", "Gc") ~ paste0(question_name, parse_number(part)),
      # Gd1/2/3 are already in the right form
      TRUE ~ question_name
    ),
    fully_correct = case_when(
      #part == "ans1" ~ str_detect(responsesummary, "prt1-1-T"),
      #question_name %in% c("Ga", "Gb")
      G_part == "Ga1" ~ str_detect(responsesummary, "prt1-1-T"),
      G_part == "Ga2" ~ str_detect(responsesummary, "prt2-4-T"),
      G_part == "Ga3" ~ str_detect(responsesummary, "prt3-4-T"),
      G_part == "Gb1" ~ str_detect(responsesummary, "prt1-1-T"),
      G_part == "Gb2" ~ str_detect(responsesummary, "prt2-4-T"),
      G_part == "Gb3" ~ str_detect(responsesummary, "prt3-4-T"),
      G_part == "Gc1" ~ str_detect(responsesummary, "prt1-1-T"),
      G_part == "Gc2" ~ str_detect(responsesummary, "prt2-1-T"),
      G_part == "Gc3" ~ str_detect(responsesummary, "prt3-7-T"),
      G_part == "Gd1" ~ str_detect(responsesummary, "prt1-1-T"),
      G_part == "Gd2" ~ str_detect(responsesummary, "prt1-1-T"),
      G_part == "Gd3" ~ str_detect(responsesummary, "prt1-2-T"),
    ),
    relevant_prt = case_when(
      question_name %in% c("Ga", "Gb", "Gc") ~ str_match_all(responsesummary, str_glue("prt{parse_number(part)}: [^;]*(?=; |$)")),
      TRUE ~ str_match_all(responsesummary, str_glue("prt1: [^;]*(?=; |$)"))
    )
  ) %>% 
  select(-contains("summary"))

responses_G_summary <- responses_G %>% 
  janitor::tabyl(G_part, fully_correct) %>% 
  rename(part = G_part, incorrect = "FALSE", correct = "TRUE")

responses_G_summary %>% 
  basic_kable()

responses_G_summary %>% 
  pivot_longer(cols = contains("correct"), names_to = "type", values_to = "count") %>% 
  ggplot(aes(x = part, y = count, fill = type)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d("Answer", option = "plasma", end = 0.8, direction = -1) +
  scale_y_continuous("Number of responses")
```

```{r}
responses_G %>% 
  group_by(G_part, fully_correct, response) %>% tally() %>% arrange(G_part, fully_correct, -n) %>% 
  write_csv("data-clean/study1/G_part_analysis.csv")
```

### Ga

For part 1 (increasing):

* the most common correct answer was `n+1` (10 responses), with most correct responses being either of the form `a*n` or `n+k`.

* the single most common incorrect answer was `1` (7 responses, and there were 4 more that were integers), perhaps because the students were "gaming the system" to see the worked solution (as noted in Kinnear et al., 2021). 
Another common class of incorrect answers were expressions involving `u_n` (`r responses_G %>% filter(G_part == "Ga1", !fully_correct, str_detect(response, "u_n")) %>% tally()` responses), i.e. taking the form of recurrence relations rather than a formula for the n'th term as requested.

For part 2 (increasing and bounded above):

* integer responses were again common as wrong answers (25 responses), suggesting students were not sure how to answer

* other incorrect responses included `(-1)^n` (x3) suggesting some confusion about "increasing"; `ln(n)` (x2) which fails to be bounded above (though students might have the misconception that it is, due to the way it is often depicted in sketches)

* the correct respones were: `-1/n` (x2), `-1/(2^n)`, `-e^(-n)` and `2-(1/2)^n`

For part 3 (increasing, bounded above, and has u4=16):

* 30 students gave an integer as their answer, though only 2 of them chose 16

* the correct responses were:

```{r}
responses_G %>% filter(G_part == "Ga3", fully_correct) %>% select(username, response) %>% distinct()
```

Focusing on those students' responses throughout Ga, there is some evidence of a "transformation" strategy (Antonini) moving from 2 to 3, as they modify their previous example to suit the new constraints:

```{r}
responses_G %>% filter(str_detect(G_part, "Ga"), str_detect(username, "anon161$|anon19$|anon97$")) %>% select(username, G_part, response) %>% distinct() %>% 
  pivot_wider(names_from = "username", values_from = "response") %>% 
  basic_kable()
```

## Outcome measures

There are various possible outcome measures, based on:

* whether to use all subsequent questions (after the learning task) or only the two questions in the Far test
* whether to focus on the marks relating to increasing/decreasing sequences and boundedness separately


```{r}
detailed_scores <- attempt_data_all %>% 
  mutate(
    marks_incdec = case_when(
      !is.na(marks_attained) & str_detect(question_name, "NearC|MidC|FarC") ~ if_else(str_detect(responsesummary, "prt1-1-T"), 1, 0),
      !is.na(marks_attained) & str_detect(question_name, "MidG") ~
        if_else(str_detect(responsesummary, "prt1-2-T"), 1, 0) + if_else(str_detect(responsesummary, "prt2-2-T"), 1, 0)
    ),
    marks_bdd = case_when(
      !is.na(marks_attained) & str_detect(question_name, "NearC|MidC|FarC") ~ if_else(str_detect(responsesummary, "prt2-1-T"), 1, 0),
      !is.na(marks_attained) & str_detect(question_name, "MidG") ~
        if_else(str_detect(responsesummary, "prt3-2-T"), 1, 0) + if_else(str_detect(responsesummary, "prt4-1-T"), 1, 0)
    )

  )

detailed_scores_summary <- detailed_scores %>% 
  filter(attempt_number == 1) %>%
  filter(str_detect(question_name, "Near|Mid|Far")) %>% 
  group_by(userid, group, overall_group) %>% 
  summarise(across(contains("marks"), sum, na.rm = TRUE), .groups = "drop") %>% 
  left_join(
    # add the scores from the Far test only
    detailed_scores %>% 
      filter(attempt_number == 1) %>%
      filter(str_detect(question_name, "Far")) %>% 
      group_by(userid, group, overall_group) %>% 
      summarise(across(c("marks_incdec", "marks_bdd"), sum, na.rm = TRUE), .groups = "drop") %>% 
      rename_with(~ str_replace(., "marks_", "marks_far_")) %>% 
      mutate(marks_far_attained = marks_far_incdec + marks_far_bdd),
    by = c("userid", "group", "overall_group")
  )

detailed_scores_summary %>% head() %>% basic_kable()

detailed_scores_summary %>% 
  pivot_longer(
    cols = contains("marks"),
    names_to = "marks_for",
    values_to = "mark",
    names_prefix = "marks_"
  ) %>% 
  filter(!str_detect(marks_for, "^a")) %>% 
  drop_na() %>% 
  ggplot(aes(x = overall_group, y = mark, colour = marks_for)) +
  geom_violin() +
  ggbeeswarm::geom_beeswarm(alpha = 0.5) +
  facet_wrap(~ marks_for, scales = "free")

detailed_scores_summary %>% 
  mutate(
    first_task = str_sub(group, start = 1, end = 1),
    later_tasks = str_sub(group, start = 3, end = 4)
  ) %>% 
  group_by(overall_group) %>%
  mutate(n = n(), group_label = str_glue("{overall_group} (n={n})")) %>%
  ungroup() %>% 
  write_csv("data-clean/study1_detail.csv")
```


Here we carry out all the analyses to compare the results.

```{r}
compute_contrasts <- function(model) {
  # inspect draws from the model, and compute the contasts of interest
  contrasts <- model %>% 
    tidy_draws() %>% 
    select(starts_with("group"), sigma) %>% 
    mutate(
      CvsG_contrast = (`groupC-CG`+`groupC-GC`)/2 - (`groupG-CG`+`groupG-GC`)/2,
      CvsG_effect = CvsG_contrast / sigma,
      CGvsGC_contrast = (`groupC-CG`+`groupG-CG`)/2 - (`groupC-GC`+`groupG-GC`)/2,
      CGvsGC_effect = CGvsGC_contrast / sigma,
    )
  contrasts_long <- contrasts %>%
    select(-starts_with("group")) %>% 
    pivot_longer(
      cols = contains("vs"),
      names_to = "parameter",
      values_to = "est"
    ) %>% 
    separate(parameter, into = c("comparison", "parameter"))
  
  contrasts_summary <- contrasts_long %>% 
    group_by(comparison, parameter) %>% 
    median_hdi(est) %>% 
    ungroup() %>% 
    mutate(formatted_hdi = str_glue("{round(est, 3)} ({.width*100}% HDI [{round(.lower, 3)}, {round(.upper, 3)}])"))
  
  return(list("contrasts_long" = contrasts_long, "contrasts_summary" = contrasts_summary))
}
```

```{r}
fit_model <- function(data) {
  stan_glm(
    formula = measure ~ 0 + group,
    data = data,
    seed = 123,
    refresh = 0 # to prevent messages about the MCMC iterations being printed
  )
}
all_comparisons <- tibble(
  measure = fct_inorder(c(
    "marks_attained",
    "marks_incdec",
    "marks_bdd",
    "marks_far_attained",
    "marks_far_incdec",
    "marks_far_bdd"
  ))
) %>%
  rowwise() %>%
  mutate(data = map(
    measure,
    ~ detailed_scores_summary %>% select(userid, group, `measure` = all_of(measure))
  )) %>%
  ungroup() %>% 
  mutate(measure_sd = map_dbl(data, ~ .x %>% summarise(marks_sd = sd(measure, na.rm = TRUE)) %>% deframe()))

all_model_fits <- all_comparisons %>% 
  mutate(model = map(data, fit_model))

all_contrasts <- all_model_fits %>% 
  mutate(contrasts = map(model, compute_contrasts)) %>% 
  unnest_wider(contrasts)

all_contrasts %>% 
  select(measure, contrasts_summary) %>% 
  unnest(cols = contrasts_summary) %>% 
  select(measure, comparison, parameter, formatted_hdi) %>% 
  pivot_wider(
    names_from = parameter,
    values_from = formatted_hdi
  ) %>%
  basic_kable()

contrast_data_for_plotting <- all_contrasts %>% 
  select(measure, measure_sd, contrasts_long) %>% 
  unnest(cols = c(contrasts_long)) %>% 
  mutate(rope_width = case_when(parameter == "contrast" ~ 0.1*measure_sd, parameter == "effect" ~ 0.1)) %>% 
  filter(parameter == "effect") %>% 
  mutate(comparison = fct_recode(comparison, "C* vs G*" = "CvsG",  "*CG vs *GC" = "CGvsGC")) %>%
  mutate(far_measure = str_detect(measure, "far")) %>% 
  mutate(
    measure = str_remove_all(measure, "marks_|far_"),
    measure = str_replace_all(
       measure,
       c(
         "attained" = "Marks attained",
         "incdec" = "Marks for\nincreasing/decreasing",
         "bdd" = "Marks for\nboundedness"
       )
     )
  )
  

plot_all <- contrast_data_for_plotting %>%
  filter(!far_measure) %>% 
  ggplot(aes(x = est, y = 0)) +
  geom_rect(aes(xmin = -rope_width, xmax = rope_width), ymin = 0, ymax = 1, fill = "skyblue", alpha = 0.1) +
  geom_vline(xintercept = 0, colour = "grey40") +
  stat_dotsinterval(
    point_interval = mode_hdi,
    .width = .95,
    slab_size = 0,
    quantiles = 100
  ) +
  scale_y_continuous(NULL, breaks = NULL) +
  expand_limits(x = c(-0.1, 0.1)) +
  xlab("Effect size") +
  facet_grid(cols = vars(comparison), rows = vars(measure), scales = "free_x", switch = "y") +
  theme(#panel.grid = element_blank(),
        axis.ticks = element_line(color = "grey40"),
        strip.text.y.left = element_text(angle = 0)
        )

plot_far_only <- contrast_data_for_plotting %>%
  filter(far_measure) %>% 
  ggplot(aes(x = est, y = 0)) +
  geom_rect(aes(xmin = -rope_width, xmax = rope_width), ymin = 0, ymax = 1, fill = "skyblue", alpha = 0.1) +
  geom_vline(xintercept = 0, colour = "grey40") +
  stat_dotsinterval(
    point_interval = mode_hdi,
    .width = .95,
    slab_size = 0,
    quantiles = 100
  ) +
  scale_y_continuous(NULL, breaks = NULL) +
  expand_limits(x = c(-0.1, 0.1)) +
  xlab("Effect size") +
  facet_grid(cols = vars(comparison), rows = vars(measure), scales = "free_x", switch = "y") +
  theme(#panel.grid = element_blank(),
        axis.ticks = element_line(color = "grey40"),
        strip.text.y.left = element_text(angle = 0)
        )

(plot_all + labs(title = "Marks on all questions")) / (plot_far_only + labs(title = "Marks on Far test questions only"))

```

## Main comparison

Since the pattern of results is basically the same for all outcome measures, we focus on `marks_attained` across all questions.

```{r}
model <- (all_model_fits %>% filter(measure == "marks_attained") %>% pull(model))[[1]]
rope_width <- 0.1*(all_model_fits %>% filter(measure == "marks_attained") %>% pull(measure_sd))[[1]]
```

```{r}
means <- modelbased::estimate_means(model, ci = ci_width, centrality = "median", ci_method = "hdi")

detailed_scores_summary %>% 
  ggplot(aes(x = group, y = marks_attained, colour = group)) +
  ggbeeswarm::geom_beeswarm(alpha = 0.5) +
  geom_pointrange(data = means, aes(x = group, y = Mean, ymin = CI_low, ymax = CI_high),
                  position = position_nudge(x = 0.3),
                  size = 0.8) +
  scale_x_discrete("", labels = detailed_scores_summary %>% filter(!is.na(marks_attained)) %>% group_by(group) %>% summarise(group_label = str_glue("{group}\n(n={n()})"), .groups = "drop") %>% deframe(), position = "top") +
  scale_y_continuous("Marks attained (out of 15)") +
  scale_colour_manual("Group", values = groupcolours) +
  theme(legend.position = "none")

ggsave("figs/FIG_study1_marks_attained.pdf", width = 12, height = 7, units = "cm")
```

```{r}
detailed_scores_summary %>% 
  group_by(group) %>% 
  summarise(
    n = sum(!is.na(marks_attained)),
    mean = mean(marks_attained, na.rm = TRUE),
    sd = sd(marks_attained, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  # group is of type "glue" so force it to be a string in order to join on it
  mutate(group = paste(group)) %>% 
  left_join(means, by = "group") %>% 
  # show the HDI but not the estimated mean since that's superfluous
  select(-Mean) %>% 
  mutate(estimate_hdi = str_glue("[{round(CI_low, 3)}, {round(CI_high, 3)}]"), .keep = "unused") %>% 
  basic_kable(caption = "Study 1 group means", digits = 3)
```


```{r compute-contrasts}
contrasts <- model %>% 
  tidy_draws() %>% 
  select(starts_with("group"), sigma) %>% 
  mutate(
    CvsG_contrast = (`groupC-CG`+`groupC-GC`)/2 - (`groupG-CG`+`groupG-GC`)/2,
    CvsG_effect = CvsG_contrast / sigma,
    CGvsGC_contrast = (`groupC-CG`+`groupG-CG`)/2 - (`groupC-GC`+`groupG-GC`)/2,
    CGvsGC_effect = CGvsGC_contrast / sigma,
  )
contrasts_long <- contrasts %>%
  select(-starts_with("group")) %>% 
  pivot_longer(
    cols = contains("vs"),
    names_to = "parameter",
    values_to = "est"
  ) %>% 
  separate(parameter, into = c("contrast", "parameter"))

contrasts_summary <- contrasts_long %>% 
  group_by(contrast, parameter) %>% 
  median_hdi(est) %>% 
  ungroup() %>% 
  mutate(formatted_hdi = str_glue("{round(est, 3)} ({.width*100}% HDI [{round(.lower, 3)}, {round(.upper, 3)}])"))

contrasts_summary %>% 
  select(measure = contrast, parameter, formatted_hdi) %>% 
  pivot_wider(
    names_from = parameter,
    values_from = formatted_hdi
  ) %>%
  basic_kable()

p_diffs <- contrasts_long %>% 
  mutate(key = fct_recode(contrast, "C- vs G-" = "CvsG",  "-CG vs -GC" = "CGvsGC")) %>%
  mutate(key = fct_relevel(key, "C- vs G-")) %>% 
  mutate(rope_width = case_when(parameter == "contrast" ~ rope_width, parameter == "effect" ~ 0.1)) %>% 
  mutate(parameter = fct_recode(parameter, "Raw scores" = "contrast",  "Effect size" = "effect")) %>%
  ggplot(aes(x = est, y = 0)) +
  geom_rect(aes(xmin = -rope_width, xmax = rope_width), ymin = 0, ymax = 1, fill = "skyblue", alpha = 0.1) +
  geom_vline(xintercept = 0, colour = "grey40") +
  stat_dotsinterval(
    point_interval = mode_hdi,
    .width = .95,
    slab_size = 0,
    quantiles = 100
  ) +
  scale_y_continuous(NULL, breaks = NULL) +
  expand_limits(x = c(-0.1, 0.1)) +
  expand_limits(y = c(-0.1)) +
  xlab("Estimated difference") +
  facet_grid(rows = vars(key), cols = vars(parameter), scales = "free_x", switch = "y") +
  theme(#panel.grid = element_blank(),
        axis.ticks = element_line(color = "grey40"),
        strip.text.y.left = element_text(angle = 0)
        )
p_diffs
ggsave("figs/FIG_study1_marks_attained_effect.pdf", width = 14, height = 5, units = "cm")
```


#### Session info

```{r}
sessionInfo()
```